# tcmalloc 性能分析工具使用指南

## 📋 概述

本目录包含三个性能分析脚本，用于分析 tcmalloc 内存池的性能表现：

1. **perf_analysis.sh** - 完整的性能分析（推荐用于深入分析）
2. **quick_perf.sh** - 快速性能检查（日常使用）
3. **compare_perf.sh** - 性能对比分析

## 🛠️ 准备工作

### 安装依赖工具

```bash
# 安装 perf
sudo apt-get install linux-tools-common linux-tools-generic linux-tools-$(uname -r)

# 安装 Valgrind
sudo apt-get install valgrind

# （可选）安装可视化工具
sudo apt-get install kcachegrind
```

### 配置 perf 权限

如果运行 perf 时遇到权限问题：

```bash
# 临时设置（重启后失效）
sudo sysctl -w kernel.perf_event_paranoid=1

# 或者永久设置
echo "kernel.perf_event_paranoid=1" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p
```

## 🚀 使用方法

### 1. 快速性能检查（推荐新手）

适合日常快速检查，耗时约 1-2 分钟：

```bash
./quick_perf.sh
```

**输出内容：**
- 编译状态
- Top 20 热点函数
- CPU 性能统计
- 内存泄漏摘要

### 2. 完整性能分析（推荐深入分析）

进行全面的性能分析，耗时约 5-10 分钟：

```bash
./perf_analysis.sh
```

**生成的分析报告：**
- `perf_report.txt` - CPU 性能热点
- `perf_stat.txt` - CPU 事件统计
- `perf_cache.txt` - Cache 性能
- `valgrind_memcheck.txt` - 内存错误检测
- `cachegrind_report.txt` - Cache 详细分析
- `callgrind_report.txt` - 函数调用图
- `massif_report.txt` - 堆内存使用
- `README.md` - 结果说明

**查看结果：**
```bash
cd perf_results_YYYYMMDD_HHMMSS/
cat README.md              # 查看说明文档
less perf_report.txt       # 查看 CPU 热点
less valgrind_memcheck.txt # 查看内存问题
```

### 3. 性能对比分析

对比 tcmalloc 的性能表现：

```bash
./compare_perf.sh
```

**生成的对比报告：**
- `comparison_report.md` - 对比摘要
- `tcmalloc_stat.txt` - 性能统计
- `tcmalloc_hotspot.txt` - 热点分析
- `tcmalloc_cachegrind.txt` - Cache 分析

## 📊 如何解读结果

### CPU 热点分析 (perf_report.txt)

```
# Overhead: 函数占用的 CPU 时间百分比
# Children: 包括子函数的总时间
# Self: 函数本身的时间

Overhead  Command  Shared Object      Symbol
  15.23%  bench    bench_debug        [.] ConcurrentAlloc
  10.45%  bench    bench_debug        [.] ThreadCache::Allocate
   8.32%  bench    bench_debug        [.] CentralCache::FetchRangeObjs
```

**关注点：**
- Overhead > 5% 的函数是优化重点
- 如果锁函数（mutex_lock）占比高，说明锁竞争严重

### CPU 性能统计 (perf_stat.txt)

```
Performance counter stats:

 10,234,567,890  cycles                    # 3.2 GHz
  8,123,456,789  instructions              # 0.79 insn per cycle
    123,456,789  cache-misses              # 2.5% of all cache refs
  4,567,890,123  cache-references
```

**关键指标：**
- **IPC (insn per cycle)**: > 1.0 较好，> 2.0 优秀
- **Cache miss rate**: < 5% 较好，< 2% 优秀
- **Branch miss rate**: < 2% 较好，< 1% 优秀

### 内存泄漏检测 (valgrind_memcheck.txt)

```
LEAK SUMMARY:
   definitely lost: 0 bytes in 0 blocks
   indirectly lost: 0 bytes in 0 blocks
     possibly lost: 0 bytes in 0 blocks
```

**理想状态：** 所有项都是 0

### Cache 性能 (cachegrind_report.txt)

```
I   refs:      1,000,000,000  # 指令读取
I1  misses:       10,000,000  # L1 指令缓存未命中
LLi misses:        1,000,000  # 末级缓存指令未命中

D   refs:        500,000,000  # 数据读取
D1  misses:       25,000,000  # L1 数据缓存未命中 (5%)
LLd misses:        5,000,000  # 末级缓存数据未命中 (1%)
```

**Cache miss rate 计算：**
- L1 miss rate = D1 misses / D refs
- LLC miss rate = LLd misses / D refs

## 🎯 性能优化建议

根据分析结果，可以从以下几个方面优化：

### 1. CPU 热点优化
- 查看 `perf_report.txt` 中 Overhead 最高的函数
- 使用更高效的算法或数据结构
- 减少不必要的计算

### 2. Cache 优化
如果 cache miss rate 高（> 5%）：
- 优化数据结构布局（考虑 cache line）
- 减少随机访问，增加顺序访问
- 使用内存预取（prefetch）

### 3. 锁优化
如果多线程测试性能差：
- 减少锁的粒度
- 使用无锁数据结构
- 考虑使用线程本地存储（TLS）

### 4. 内存优化
- 消除所有内存泄漏
- 减少内存碎片
- 优化内存分配策略

## 📈 可视化分析

### 使用 kcachegrind 查看调用图

```bash
cd perf_results_YYYYMMDD_HHMMSS/
kcachegrind callgrind.out
```

**功能：**
- 可视化函数调用关系
- 查看每个函数的时间占用
- 分析调用链路

### 使用 perf report 交互式查看

```bash
cd perf_results_YYYYMMDD_HHMMSS/
perf report -i perf.data
```

**快捷键：**
- `Enter`: 展开函数
- `+`: 展开所有子函数
- `/`: 搜索函数
- `q`: 退出

## 🔍 常见问题

### Q1: perf 提示权限不足
```bash
sudo sysctl -w kernel.perf_event_paranoid=1
```

### Q2: Valgrind 运行太慢
Valgrind 会让程序慢 10-50 倍，这是正常的。可以减少测试迭代次数。

### Q3: 找不到符号信息
确保使用 `-g` 编译选项，Makefile 中已包含。

### Q4: Cache miss rate 看起来很高
- 这在内存分配器中是正常的，因为访问模式本身就是随机的
- 重点是对比优化前后的差异

## 📝 示例工作流

```bash
# 1. 首次分析 - 建立基线
./perf_analysis.sh

# 2. 记录当前性能数据
cp -r perf_results_* baseline/

# 3. 进行代码优化
# （修改代码）

# 4. 再次分析
./compare_perf.sh

# 5. 对比结果
# 比较两次的 perf_stat.txt 和程序输出

# 6. 日常快速检查
./quick_perf.sh
```

## 🎓 进阶使用

### 自定义测试参数

编辑脚本中的测试参数：
```bash
# 修改迭代次数
ITERATIONS=1000000  # 改为你想要的值
```

### 添加自定义 perf 事件

```bash
perf list  # 查看所有可用事件
perf stat -e event1,event2,event3 ./bench_debug
```

### 火焰图生成

```bash
# 安装 FlameGraph
git clone https://github.com/brendangregg/FlameGraph.git

# 生成火焰图
perf record -F 99 -g ./bench_debug
perf script | FlameGraph/stackcollapse-perf.pl | FlameGraph/flamegraph.pl > flame.svg
```

## 📚 参考资料

- [perf 官方文档](https://perf.wiki.kernel.org/)
- [Valgrind 用户手册](https://valgrind.org/docs/manual/)
- [Linux 性能优化实战](https://time.geekbang.org/column/intro/140)

## ⚠️ 注意事项

1. **性能测试要在相对空闲的系统上进行**，避免其他程序干扰
2. **多次运行取平均值**，单次结果可能有波动
3. **关注相对性能提升**，而不是绝对数值
4. **在发布版本测试前**，确保使用 `-O2` 或 `-O3` 优化
5. **Valgrind 结果仅供参考**，实际性能以 perf 为准

---

创建日期: 2025-11-12  
版本: 1.0
